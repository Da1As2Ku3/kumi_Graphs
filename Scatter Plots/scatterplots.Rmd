---
title: "Scatter Plots"
author: "David Asare Kumi"
date: "4/8/2020"
output: html_document
---


## Scatter Plots

- Scatter plots are used to display the relationship between two continuous variables. In
a scatter plot, each observation in a data set is represented by a point. Often, a scatter
plot will also have a line showing the predicted values based on some statistical model.
This is easy to do with R and ggplot2, and can help to make sense of data when the
trends aren’t immediately obvious just by looking at it.

- With large data sets, it can be problematic to plot every single observation because the
points will be overplotted, obscuring one another. When this happens, you’ll probably
want to summarize the data before displaying it. We’ll also see how to do that in this
chapter.

## Making a Basic Scatter Plot

- You want to make a scatter plot.

- Use geom_point(), and map one variable to x and one to y.

- In the heightweight data set, there are a number of columns, but we’ll only use two in
this example.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
data(heightweight)
head(heightweight)

# List the two columns we'll use
ht<-heightweight[, c("ageYear", "heightIn")]
head(ht)

ggplot(heightweight, aes(x=ageYear, y=heightIn)) + geom_point(color="red",size=1)

```

- To use different shapes in a scatter plot, set shape. A common alternative to the default
solid circles (shape #16) is hollow ones (#21), as seen below.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
data(heightweight)
head(heightweight)

g1<-ggplot(heightweight, aes(x=ageYear, y=heightIn)) + geom_point(shape=21)
g2<-ggplot(heightweight, aes(x=ageYear, y=heightIn)) + geom_point(size=1.5)

grid.arrange(g1,g2,ncol=2)

```

- The size of the points can be controlled with size. The default value of size is 2. The
following will set size=1.5, for smaller points.

- When displaying to screen or outputting to bitmap files like PNG, the default solid circle shape (#16) can result in aliased (jagged-looking) edges on some platforms. An alternative is to use shape 19, which is also a solid circle, but comes out smooth in more cases (see Figure 5-3). See
Recipe 14.5 for more about anti-aliased output.

## Grouping Data Points by a Variable Using Shape or Color

- You want to group points by some variable, using shape or color.

- Map the grouping variable to shape or colour. In the heightweight data set, there are many columns, but we’ll only use three of them in this example:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
data(heightweight)

# Show the three columns we'll use
ht<-heightweight[, c("sex", "ageYear", "heightIn")]
head(ht)

g1<-ggplot(heightweight, aes(x=ageYear, y=heightIn, colour=sex)) + geom_point()
ggplotly(g1)
g2<-ggplot(heightweight, aes(x=ageYear, y=heightIn, shape=sex)) + geom_point()
ggplotly(g2)

grid.arrange(g1,g2,ncol=2)

```

- We can group points on the variable sex, by mapping sex to one of the aesthetics colour or shape.

- The grouping variable must be categorical—in other words, a factor or character vector.
If it is stored as a vector of numeric values, it should be converted to a factor before it is
used as a grouping variable.

- It is possible to map a variable to both shape and colour, or, if you have multiple grouping
variables, to map different variables to them. Here, we’ll map sex to shape and
colour.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
data(heightweight)

g1<-ggplot(heightweight, aes(x=ageYear, y=heightIn, shape=sex, colour=sex)) + geom_point()
ggplotly(g1)

g2<-ggplot(heightweight, aes(x=ageYear, y=heightIn, shape=sex, colour=sex)) + geom_point() + scale_shape_manual(values=c(1,2)) + scale_colour_brewer(palette="Set1")
ggplotly(g2)

grid.arrange(g1,g2,ncol=2)

```

- The default shapes and colors may not be very appealing. Other shapes can be used with
scale_shape_manual(), and other colors can be used with scale_colour_brewer() or scale_colour_manual().

- This will set different shapes and colors for the grouping variables.

## Using Different Point Shapes

- You want to use point shapes that are different from the defaults.

- If you want to set the shape of all the points, specify the shape in geom_point().


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
data(heightweight)

g1<-ggplot(heightweight, aes(x=ageYear, y=heightIn)) + geom_point(shape=3)
ggplotly(g1)

# Use slightly larger points and use a shape scale with custom values
g2<-ggplot(heightweight, aes(x=ageYear, y=heightIn, shape=sex)) + geom_point(size=3) + scale_shape_manual(values=c(1, 4))
ggplotly(g2)

grid.arrange(g1,g2,ncol=2)

```

- If you have mapped a variable to shape, use scale_shape_manual() to change the shapes.

## Shapes available in R graphics

- The shapes that are available in R graphics are numbered from 1 to 25. Some of the point shapes
(1–14) have just an outline, some (15–20) are solid, and some (21–25) have an outline and fill that can be controlled separately. (You can also use characters for points and these include hash tag,asterik,zero,minus,plus,percentage etc.)

- For shapes 1–20, the color of the entire point—even the points that are solid—is controlled
by the colour aesthetic. For shapes 21–25, the outline is controlled by colour
and the fill is controlled by fill.

- It’s possible to have the shape represent one variable and the fill (empty or solid) represent
another variable. This is done a little indirectly, by choosing shapes that have both
colour and fill, and a color palette that includes NA and another color (the NA will
result in a hollow shape). For example, we’ll take the heightweight data set and add
another column that indicates whether the child weighed 100 pounds or more.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
data(heightweight)

# Make a copy of the data
hw <- heightweight

# Categorize into <100 and >=100 groups
hw$weightGroup <- cut(hw$weightLb, breaks=c(-Inf, 100, Inf),labels=c("< 100", ">= 100"))

# Use shapes with fill and color, and use colors that are empty (NA) and fill.

g1<-ggplot(hw, aes(x=ageYear, y=heightIn, shape=sex, fill=weightGroup)) + geom_point(size=2.5) +
scale_shape_manual(values=c(21, 24)) + scale_fill_manual(values=c(NA, "black"),
guide=guide_legend(override.aes=list(shape=21)))

ggplotly(g1)

```

## Mapping a Continuous Variable to Color or Size

- You want to represent a third continuous variable using color or size.

- Map the continuous variable to size or colour. In the heightweight data set, there are
many columns, but we’ll only use four of them in this example.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
data(heightweight)

# List the four columns we'll use
hw<-heightweight[, c("sex", "ageYear", "heightIn", "weightLb")]
head(hw)

g1<-ggplot(heightweight, aes(x=ageYear, y=heightIn, colour=weightLb)) + geom_point()
ggplotly(g1)
g2<-ggplot(heightweight, aes(x=ageYear, y=heightIn, size=weightLb)) + geom_point()
ggplotly(g2)

grid.arrange(g1,g2,ncol=2)

```

- The basic scatter plot above shows the relationship between the continuous variables
ageYear and heightIn. To represent a third continuous variable, weightLb, we
must map it to another aesthetic property. We can map it to colour or size, as shown above.

- A basic scatter plot shows the relationship between two continuous variables: one mapped
to the x-axis, and one to the y-axis. When there are more than two continuous
variables, they must be mapped to other aesthetics: size and/or color.

- We can easily perceive small differences in spatial position, so we can interpret the
variables mapped to x and y coordinates with high accuracy. We aren’t very good at
perceiving small differences in size and color, though, so we will interpret variables
mapped to these aesthetic attributes with a much lower accuracy. When you map a
variable to one of these properties, it should be one where accuracy is not very important
for interpretation.

- When a variable is mapped to size, the results can be perceptually misleading. Thelargest dots in Figure 5-9 have about 36 times the area of the smallest ones, but they represent only about 3.5 times the weight. If it is important for the sizes to proportionallyrepresent the quantities, you can change the range of sizes. By default the sizes of points go from 1 to 6 mm. You could reduce the range to, say, 2 to 5 mm, with scale_size_continuous(range=c(2, 5)). However, the point size numbers don’t map linearly to diameteror area, so this still won’t give a very accurate representation of the values. 

- When it comes to color, there are actually two aesthetic attributes that can be used:
colour and fill. For most point shapes, you use colour. However, shapes 21–25 have an outline with a solid region in the middle where the color is controlled by fill. These outlined shapes can be useful when using a color scale with light colors, as in Figure 5-10, because the outline sets them off from the background. In this example, we also set the fill gradient to go from black to white and make the points larger so that the fill is easier to see.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
data(heightweight)

g1<-ggplot(heightweight, aes(x=weightLb, y=heightIn, fill=ageYear)) + geom_point(shape=21, size=2.5) +
scale_fill_gradient(low="black", high="white")
ggplotly(g1)

# Using guide_legend() will result in a discrete legend instead of a colorbar

g2<-ggplot(heightweight, aes(x=weightLb, y=heightIn, fill=ageYear)) + geom_point(shape=21, size=2.5) + scale_fill_gradient(low="black", high="white", breaks=12:17,guide=guide_legend())
ggplotly(g2)

grid.arrange(g1,g2,ncol=2)

```

- When we map a continuous variable to an aesthetic, that doesn’t prevent us from mapping a categorical variable to other aesthetics. In Figure 5-11, we’ll map weightLb to size, and also map sex to colour. Because there is a fair amount of overplotting, we’llmake the points 50% transparent by setting alpha=.5. We’ll also use scale_size_area() to make the area of the points proportional to the value (see Recipe 5.12), and change the color palette to one that is a little more appealing.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
data(heightweight)

ggplot(heightweight, aes(x=ageYear, y=heightIn, size=weightLb, colour=sex)) +
geom_point(alpha=.5) +
scale_size_area() + # Make area proportional to numeric value
scale_colour_brewer(palette="Set1")

```

- When a variable is mapped to size, it’s a good idea to not map a variable to shape. This
is because it is difficult to compare the sizes of different shapes; for example, a size 4
triangle could appear larger than a size 3.5 circle. Also, some of the shapes really are
different sizes: shapes 16 and 19 are both circles, but at any given numeric size, shape
19 circles are visually larger than shape 16 circles.

## Dealing with Overplotting

- You have many points and they obscure each other.

- With large data sets, the points in a scatter plot may obscure each other and prevent the
viewer from accurately assessing the distribution of the data. This is called overplotting.
If the amount of overplotting is low, you may be able to alleviate it by using smaller
points, or by using a different shape (like shape 1, a hollow circle) through which other
points can be seen. Figure 5-2 in Recipe 5.1 demonstrates both of these solutions.

- If there’s a high degree of overplotting, there are a number of possible solutions:
1. Make the points semitransparent.

2. Bin the data into rectangles (better for quantitative analysis).

3. Bin the data into hexagons.

4. Use box plots.

- The scatter plot in Figure 5-12 contains about 54,000 points. They are heavily overplotted,
making it impossible to get a sense of the relative density of points in different areas
of the graph.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
data(diamonds)

sp <- ggplot(diamonds, aes(x=carat, y=price))
sp + geom_point()

```

- We can make the points semitransparent using alpha, as in Figure 5-13. Here, we’ll make
them 90% transparent and then 99% transparent, by setting alpha=.1 and alpha=.01.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
data(diamonds)

sp <- ggplot(diamonds, aes(x=carat, y=price))

sp + geom_point(alpha=.1)
sp + geom_point(alpha=.01)

```

- Now we can see that there are vertical bands at nice round values of carats, indicating
that diamonds tend to be cut to those sizes. Still, the data is so dense that even when the
points are 99% transparent, much of the graph appears solid black, and the data distribution
is still somewhat obscured.

- For most graphs, vector formats (such as PDF, EPS, and SVG) result in smaller output files than bitmap formats (such as TIFF and PNG). But in cases where there are tens of thousands of points, vector output files can be very large and slow to render—the scatter plot here with 99% transparent points is 1.5 MB! In these cases, high-resolution bitmaps will be smaller and faster to display on computer screens.

- Another solution is to bin the points into rectangles and map the density of the points to the fill color of the rectangles, as shown in Figure 5-14. With the binned visualization, the vertical bands are barely visible. The density of points in the lower-left corner is much greater, which tells us that the vast majority of diamonds are small and inexpensive.

- By default, stat_bin_2d() divides the space into 30 groups in the x and y directions, for a total of 900 bins. In the second version, we increase the number of bins with bins=50.

- The default colors are somewhat difficult to distinguish because they don’t vary much in luminosity. In the second version we set the colors by using scale_fill_gradient() and specifying the low and high colors. By default, the legend doesn’t show an entry for the lowest values. This is because the range of the color scale starts not from zero, but from the smallest nonzero quantity in a bin—probably 1, in this case. To make the legend show a zero (as in Figure 5-14, right), we can manually set the range from 0 to the maximum, 6000, using limits.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
data(diamonds)

sp <- ggplot(diamonds, aes(x=carat, y=price))
sp + stat_bin2d()

sp + stat_bin2d(bins=50) +
scale_fill_gradient(low="lightblue", high="red", limits=c(0, 6000))

```

- Another alternative is to bin the data into hexagons instead of rectangles, with stat_bin
hex() (Figure 5-15). It works just like stat_bin2d(). To use it, you must first install the
hexbin package, with install.packages("hexbin").

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(diamonds)

g1<-sp + stat_binhex() + scale_fill_gradient(low="lightblue", high="red", limits=c(0, 8000))
ggplotly(g1)

```


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(diamonds)

sp <- ggplot(diamonds, aes(x=carat, y=price))
g1<-sp + stat_bin2d(bins=50) + scale_fill_gradient(low="lightblue", high="red", limits=c(0, 6000))
g2<-sp + stat_binhex() + scale_fill_gradient(low="lightblue", high="red", limits=c(0, 8000))

grid.arrange(g1,g2,ncol=2)

```

- For both of these methods, if you manually specify the range, and there is a bin that falls
outside that range because it has too many or too few points, that bin will show up as
grey rather than the color at the high or low end of the range, as seen in the graph on
the right in Figure 5-15.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(diamonds)

sp <- ggplot(diamonds, aes(x=carat, y=price))
sp + stat_binhex() + scale_fill_gradient(low="lightblue", high="red",
breaks=c(0, 250, 500, 1000, 2000, 4000, 6000),limits=c(0, 6000))

```

- Overplotting can also occur when the data is discrete on one or both axes, as shown in
Figure 5-16. In these cases, you can randomly jitter the points with position_jit
ter(). By default the amount of jitter is 40% of the resolution of the data in each direction,
but these amounts can be controlled with width and height:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(ChickWeight)

sp1 <- ggplot(ChickWeight, aes(x=Time, y=weight))

g1<-sp1 + geom_point()

g2<-sp1 + geom_point(position="jitter")

# Could also use geom_jitter(), which is equivalent
g3<-sp1 + geom_point(position=position_jitter(width=.5, height=0))

grid.arrange(g1,g2,g3,ncol=3)

```

- When the data has one discrete axis and one continuous axis, it might make sense to
use box plots, as shown in Figure 5-17. This will convey a different story than a standard
scatter plot because it will obscure the number of data points at each location on the
discrete axis. This may be problematic in some cases, but desirable in others.

- With the ChickWeights data, the x-axis is conceptually discrete, but since it is stored
numerically, ggplot() doesn’t know how to group the data for each box. If you don’t
tell it how to group the data, you get a result like the graph on the right in Figure 5-17.
To tell it how to group the data, use aes(group=...). In this case, we’ll group by each
distinct value of Time.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(ChickWeight)

sp1 <- ggplot(ChickWeight, aes(x=Time, y=weight))

sp1 + geom_boxplot(aes(group=Time))

```

## Adding Fitted Regression Model Lines

- You want to add lines from a fitted regression model to a scatter plot.

- To add a linear regression line to a scatter plot, add stat_smooth() or geom_smooth() and tell it to use method=lm. This instructs it to fit the data with the lm() (linear model) function. First
we’ll save the base plot object in sp, then we’ll add different components to it.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

# The base plot
sp <- ggplot(heightweight, aes(x=ageYear, y=heightIn))
g1<-sp + geom_point() + stat_smooth(method=lm)
ggplotly(g1)
g2<-sp + geom_point() + geom_smooth(method=lm)
ggplotly(g2)

# The two codes produce the same plot

grid.arrange(g1,g2,ncol=2)

```

- By default, stat_smooth() also adds a 95% confidence region for the regression fit. The
confidence interval can be changed by setting level, or it can be disabled with se=FALSE.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

# The base plot
sp <- ggplot(heightweight, aes(x=ageYear, y=heightIn))

# 99% confidence region
g1<-sp + geom_point() + stat_smooth(method=lm, level=0.99)
ggplotly(g1)

# No confidence region
g2<-sp + geom_point() + stat_smooth(method=lm, se=FALSE)
ggplotly(g2)

grid.arrange(g1,g2,ncol=2)

```

- The default color of the fit line is blue. This can be changed by setting colour. As with
any other line, the attributes linetype and size can also be set. To emphasize the line,
you can make the dots less prominent by setting colour.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

# The base plot
sp <- ggplot(heightweight, aes(x=ageYear, y=heightIn))
g1<-sp + geom_point(colour="red",size=1) + stat_smooth(method=lm, se=FALSE, colour="black")
ggplotly(g1)

```

- The linear regression line is not the only way of fitting a model to the data—in fact, it’s
not even the default. If you add stat_smooth() without specifying the method, it will
use a loess (locally weighted polynomial) curve, as shown in Figure 5-19. Both of these
will have the same result.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

# The base plot
sp <- ggplot(heightweight, aes(x=ageYear, y=heightIn))

g1<-sp + geom_point(colour="grey60") + stat_smooth()
ggplotly(g1)

g2<-sp + geom_point(colour="grey60") + stat_smooth(method=loess)
ggplotly(g2)

grid.arrange(g1,g2,ncol=2)

```

- Additional parameters can be passed along to the loess() function by just passing them to stat_smooth().

## Logistic Regression

- Another common type of model fit is a logistic regression. Logistic regression isn’t appropriate
for the heightweight data set, but it’s perfect for the biopsy data set in the MASS library. In this data set, there are nine different measured attributes of breast cancer biopsies, as well as the class of the tumor, which is either benign or malignant. To prepare the data for logistic regression, we must convert the factor class, with the levels benign and malignant, to a vector with numeric values of 0 and 1. We’ll make a copy of the biopsy data frame, then store the numeric coded class in a column called classn.

- Although there are many attributes we could examine, for this example we’ll just look
at the relationship of V1 (clump thickness) and the class of the tumor. Because there is
a large degree of overplotting, we’ll jitter the points and make them semitransparent
(alpha=0.4), hollow (shape=21), and slightly smaller (size=1.5). Then we’ll add a fitted
logistic regression line (Figure 5-20) by telling stat_smooth() to use the glm() function
with the option family=binomial.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
library(MASS) # for the data set

b <- biopsy
b$classn[b$class=="benign"] <- 0
b$classn[b$class=="malignant"] <- 1

g1<-ggplot(b, aes(x=V1, y=classn)) + geom_point(position=position_jitter(width=0.3, height=0.06), alpha=0.4, shape=21, size=1.5) + stat_smooth(method=glm, family=binomial)
ggplotly(g1)

```

- If your scatter plot has points grouped by a factor, using colour or shape, one fit line
will be drawn for each group. First we’ll make the base plot object sps, then we’ll add
the loess lines to it. We’ll also make the points less prominent by making them semitransparent,
using alpha=.4.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight) 

sps <- ggplot(heightweight, aes(x=ageYear, y=heightIn, colour=sex)) + geom_point() + scale_colour_brewer(palette="Set1")

g1<-sps + geom_smooth()
ggplotly(g1)

g2<-sps + geom_smooth(method="lm",se=FALSE)
ggplotly(g2)

grid.arrange(g1,g2,ncol=2)

```

- Notice that the blue line, for males, doesn’t run all the way to the right side of the graph.
There are two reasons for this. The first is that, by default, stat_smooth() limits the
prediction to within the range of the predictor data (on the x-axis). The second is that
even if it extrapolates, the loess() function only offers prediction within the x range of
the data.

- If you want the lines to extrapolate from the data, as shown in the right-hand image of
Figure 5-21, you must use a model method that allows extrapolation, like lm(), and pass
stat_smooth() the option fullrange=TRUE:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

sps <- ggplot(heightweight, aes(x=ageYear, y=heightIn, colour=sex)) + geom_point() + scale_colour_brewer(palette="Set1")

sps + geom_smooth(method=lm, se=FALSE, fullrange=TRUE)

```

- In this example with the heightweight data set, the default settings for stat_smooth()
(with LOESS and no extrapolation) make more sense than the extrapolated linear predictions,
because we don’t grow linearly and we don’t grow forever.

## Adding Fitted Lines from an Existing Model

- You have already created a fitted regression model object for a data set, and you want
to plot the lines for that model.

- Usually the easiest way to overlay a fitted model is to simply ask stat_smooth() to do
it for you, as described in Recipe 5.6. Sometimes, however, you may want to create the
model yourself and then add it to your graph. This allows you to be sure that the model
you’re using for other calculations is the same one that you see.

- In this example, we’ll build a quadratic model using lm() with ageYear as a predictor
of heightIn. Then we’ll use the predict() function and find the predicted values of
heightIn across the range of values for the predictor, ageYear:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

model <- lm(heightIn ~ ageYear + I(ageYear^2), heightweight)
model

# Create a data frame with ageYear column, interpolating across range
xmin <- min(heightweight$ageYear)
xmax <- max(heightweight$ageYear)
predicted <- data.frame(ageYear=seq(xmin, xmax, length.out=100))

# Calculate predicted values of heightIn
predicted$heightIn <- predict(model, predicted)
head(predicted)

```

- We can now plot the data points along with the values predicted from the model.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

model <- lm(heightIn ~ ageYear + I(ageYear^2), heightweight)

# Create a data frame with ageYear column, interpolating across range
xmin <- min(heightweight$ageYear)
xmax <- max(heightweight$ageYear)
predicted <- data.frame(ageYear=seq(xmin, xmax, length.out=100))

# Calculate predicted values of heightIn
predicted$heightIn <- predict(model, predicted)
head(predicted)

sp <- ggplot(heightweight, aes(x=ageYear, y=heightIn)) +
geom_point(colour="grey40")

sp + geom_line(data=predicted, size=1)

```

- With the heightweight data set, we’ll make a linear model with lm() and a LOESS model
with loess().

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

sp <- ggplot(heightweight, aes(x=ageYear, y=heightIn)) + geom_point(colour="grey40")

predictvals <- function(model, xvar, yvar, xrange=NULL, samples=100, ...) {
# If xrange isn't passed in, determine xrange from the models.
# Different ways of extracting the x range, depending on model type
if (is.null(xrange)) {
if (any(class(model) %in% c("lm", "glm")))
xrange <- range(model$model[[xvar]])
else if (any(class(model) %in% "loess"))
xrange <- range(model$x)
}
newdata <- data.frame(x = seq(xrange[1], xrange[2], length.out = samples))
names(newdata) <- xvar
newdata[[yvar]] <- predict(model, newdata = newdata, ...)
newdata
}

modlinear <- lm(heightIn ~ ageYear, heightweight)
modloess <- loess(heightIn ~ ageYear, heightweight)

#Then we can call predictvals() on each model, and pass the resulting data frames to geom_line()

lm_predicted <- predictvals(modlinear, "ageYear", "heightIn")
loess_predicted <- predictvals(modloess, "ageYear", "heightIn")

sp + geom_line(data=lm_predicted, colour="red", size=.8) + geom_line(data=loess_predicted, colour="blue", size=.8)
  
```

- For glm models that use a nonlinear link function, you need to specify type="response" to the predictvals() function. This is because the default behavior is to return predicted values in the scale of the linear predictors, instead of in the scale of the response (y) variable.

- To illustrate this, we’ll use the biopsy data set from the MASS library. As we did in Recipe 5.6, we’ll use V1 to predict class. Since logistic regression uses values from 0 to 1, while class is a factor, we’ll first have to convert class to 0s and 1s:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
library(MASS) # For the data set

b <- biopsy
b$classn[b$class=="benign"] <- 0
b$classn[b$class=="malignant"] <- 1

#Next, we’ll perform the logistic regression:
fitlogistic <- glm(classn ~ V1, b, family=binomial)


```

- Finally, we’ll make the graph with jittered points and the fitlogistic line. We’ll make the line in a shade of blue by specifying a color in RGB values, and slightly thicker, with size=1.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
library(MASS) # For the data set

b <- biopsy
b$classn[b$class=="benign"] <- 0
b$classn[b$class=="malignant"] <- 1

#Next, we’ll perform the logistic regression:
fitlogistic <- glm(classn ~ V1, b, family=binomial)

# Get predicted values
glm_predicted <- predictvals(fitlogistic, "V1", "classn", type="response")
ggplot(b, aes(x=V1, y=classn)) +
geom_point(position=position_jitter(width=.3, height=.08), alpha=0.4,
shape=21, size=1.5) + geom_line(data=glm_predicted, colour="#1177FF", size=1)

```


## Adding Fitted Lines from Multiple Existing Models

- You have already created a fitted regression model object for a data set, and you want
to plot the lines for that model.

- Use the predictvals() function from the previous recipe along with dlply() and
ldply() from the plyr package.

- With the heightweight data set, we’ll make a linear model with lm() for each of the
levels of sex, and put those model objects in a list. The model building is done with a
function, make_model(), defined here. If you pass it a data frame, it simply returns an
lm object. The model can be customized for your data.

- With the  function below, we can use the dlply() function to build a model for each subset of
data. This will split the data frame into subsets by the grouping variable sex, and apply
make_model() to each subset. In this case, the heightweight data will be split into two
data frames, one for males and one for females, and make_model() will be run on each
subset. With dlply(), the models are put into a list and the list is returned.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

make_model <- function(data) {
lm(heightIn ~ ageYear, data)
}

library(plyr)
models <- dlply(heightweight, "sex", .fun = make_model)
# Print out the list of two lm objects, f and m 

models

```

- Now that we have the list of model objects, we can run predictvals() to get predicted
values from each model, using the ldply() function.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

make_model <- function(data) {
lm(heightIn ~ ageYear, data)
}

library(plyr)
models <- dlply(heightweight, "sex", .fun = make_model)

predictvals <- function(model, xvar, yvar, xrange=NULL, samples=100, ...) {
# If xrange isn't passed in, determine xrange from the models.
# Different ways of extracting the x range, depending on model type
if (is.null(xrange)) {
if (any(class(model) %in% c("lm", "glm")))
xrange <- range(model$model[[xvar]])
else if (any(class(model) %in% "loess"))
xrange <- range(model$x)
}
newdata <- data.frame(x = seq(xrange[1], xrange[2], length.out = samples))
names(newdata) <- xvar
newdata[[yvar]] <- predict(model, newdata = newdata, ...)
newdata
}

predvals <- ldply(models, .fun=predictvals, xvar="ageYear", yvar="heightIn")
head(predvals)

#Finally, we can plot the data with the predicted values

ggplot(heightweight, aes(x=ageYear, y=heightIn, colour=sex)) +
geom_point() + geom_line(data=predvals)



```

- The dlply() and ldply() calls are used for splitting the data into parts, running functions
on those parts, and then reassembling the output.
With the preceding code, the x range of the predicted values for each group spans the x
range of each group, and no further; for the males, the prediction line stops at the oldest
male, while for females, the prediction line continues further right, to the oldest female.
To form prediction lines that have the same x range across all groups, we can simply pass in xrange, like this:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

make_model <- function(data) {
lm(heightIn ~ ageYear, data)
}

library(plyr)
models <- dlply(heightweight, "sex", .fun = make_model)

predictvals <- function(model, xvar, yvar, xrange=NULL, samples=100, ...) {
# If xrange isn't passed in, determine xrange from the models.
# Different ways of extracting the x range, depending on model type
if (is.null(xrange)) {
if (any(class(model) %in% c("lm", "glm")))
xrange <- range(model$model[[xvar]])
else if (any(class(model) %in% "loess"))
xrange <- range(model$x)
}
newdata <- data.frame(x = seq(xrange[1], xrange[2], length.out = samples))
names(newdata) <- xvar
newdata[[yvar]] <- predict(model, newdata = newdata, ...)
newdata
}

predvals <- ldply(models, .fun=predictvals, xvar="ageYear", yvar="heightIn",
xrange=range(heightweight$ageYear))

#Then we can plot it, the same as we did before:

ggplot(heightweight, aes(x=ageYear, y=heightIn, colour=sex)) +
geom_point() + geom_line(data=predvals)

```

- As you can see in the Figure above, the line for males now extends as far to the right as the
line for females. Keep in mind that extrapolating past the data isn’t always appropriate,
though; whether or not it’s justified will depend on the nature of your data and the
assumptions you bring to the table.


## Adding Annotations with Model Coefficients

- You want to add numerical information about a model to a plot.

- To add simple text to a plot, simply add an annotation. In this example, we’ll create a
linear model and use the predictvals() function defined in Recipe 5.7 to create a
prediction line from the model. Then we’ll add an annotation.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

model <- lm(heightIn ~ ageYear, heightweight)
summary(model)

```

- This shows that the r2 value is 0.4249. We’ll create a graph and manually add the text
using annotate().

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

# First generate prediction data
pred <- predictvals(model, "ageYear", "heightIn")
sp <- ggplot(heightweight, aes(x=ageYear, y=heightIn)) + geom_point() + geom_line(data=pred)

sp + annotate("text", label="r^2=0.42", x=16.5, y=52)

```

- Instead of using a plain text string, it’s also possible to enter formulas using R’s math
expression syntax, by setting parse=TRUE.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

sp + annotate("text", label="r^2 == 0.42", parse = TRUE, x=16.5, y=52)

```

- Text geoms in ggplot2 do not take expression objects directly; instead, they take character
strings that are turned into expressions with parse(text="a + b").

- If you use a math expression, the syntax must be correct for it to be a valid R expression
object. You can test validity by wrapping it in expression() and seeing if it throws an
error (make sure not to use quotes around the expression). In the example here, == is a
valid construct in an expression to express equality, but = is not.

- expression(r^2 == 0.42). This is valid.

- expression(r^2 = 0.42). This is not valid.

- It’s possible to automatically extract values from the model object and build an expression
using those values. In this example, we’ll create a string that, when parsed, returns
a valid expression:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

eqn <- as.character(as.expression(
substitute(italic(y) == a + b * italic(x) * "," ~~ italic(r)^2 ~ "=" ~ r2,
list(a = format(coef(model)[1], digits=3),
b = format(coef(model)[2], digits=3),
r2 = format(summary(model)$r.squared, digits=2)
))))
eqn

parse(text=eqn) # Parsing turns it into an expression

```

- Now that we have the expression string, we can add it to the plot. In this example we’ll
put the text in the bottom-right corner, by setting x=Inf and y=-Inf and using horizontal
and vertical adjustments so that the text all fits inside the plotting area

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(heightweight)

sp <- ggplot(heightweight, aes(x=ageYear, y=heightIn)) + geom_point() + geom_line(data=pred)

sp + annotate("text", label=eqn, parse=TRUE, x=Inf, y=-Inf, hjust=1.1, vjust=-.5)

```

## Adding Marginal Rugs to a Scatter Plot

- You want to add marginal rugs to a scatter plot.

- Use geom_rug(). For this example (Figure 5-28), we’ll use the faithful data set, which
contains data about the Old Faithful geyser in two columns—eruptions, which is the
length of each eruption, and waiting, which is the length of time to the next eruption.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(faithful)

ggplot(faithful, aes(x=eruptions, y=waiting)) + geom_point() + geom_rug()

```

- A marginal rug plot is essentially a one-dimensional scatter plot that can be used to
visualize the distribution of data on each axis.

- In this particular data set, the marginal rug is not as informative as it could be. The
resolution of the waiting variable is in whole minutes, and because of this, the rug lines
have a lot of overplotting. To reduce the overplotting, we can jitter the line positions and
make them slightly thinner by specifying size (Figure 5-29). This helps the viewer see
the distribution more clearly:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(faithful)

ggplot(faithful, aes(x=eruptions, y=waiting)) + geom_point() +
geom_rug(position="jitter", size=.2)

```

## Labeling Points in a Scatter Plot

- You want to add labels to points in a scatter plot.

- For annotating just one or a few points, you can use annotate() or geom_text(). For
this example, we’ll use the countries data set and visualize the relationship between
health expenditures and infant mortality rate per 1,000 live births. To keep things manageable,
we’ll just take the subset of countries that spent more than $2000 USD per capita.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(countries)

subset(countries, Year==2009 & healthexp>2000)

```

- We’ll save the basic scatter plot object in sp and add then add things to it. To manually
add annotations, use annotate(), and specify the coordinates and label (Figure 5-30,
left). It may require some trial-and-error tweaking to get them positioned just right:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(countries)

sp <- ggplot(subset(countries, Year==2009 & healthexp>2000),
aes(x=healthexp, y=infmortality)) + geom_point()

g1<-sp + annotate("text", x=4350, y=5.4, label="Canada") +
annotate("text", x=7400, y=6.8, label="USA")
ggplotly(g1)

g2<-sp + geom_text(aes(label=Name), size=4)
ggplotly(g2)

grid.arrange(g1,g2,ncol=2)

```

- To automatically add the labels from your data (Figure 5-30, right), use geom_text()
and map a column that is a factor or character vector to the label aesthetic. In this case,
we’ll use Name, and we’ll make the font slightly smaller to reduce crowding. The default
value for size is 5, which doesn’t correspond directly to a point size:

- The automatic method for placing annotations centers each annotation on the x and y
coordinates. You’ll probably want to shift the text vertically, horizontally, or both.
Setting vjust=0 will make the baseline of the text on the same level as the point
(Figure 5-31, left), and setting vjust=1 will make the top of the text level with the point.
This usually isn’t enough, though—you can either increase or decrease vjust to shift
the labels higher or lower, or you can add or subtract a bit to or from the y mapping to
get the same effect (Figure 5-31, right):


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(countries)

sp <- ggplot(subset(countries, Year==2009 & healthexp>2000),
aes(x=healthexp, y=infmortality)) + geom_point()

g1<-sp + geom_text(aes(label=Name), size=4, vjust=0)

# Add a little extra to y
g2<-sp + geom_text(aes(y=infmortality+.1, label=Name), size=4, vjust=0)

grid.arrange(g1,g2,ncol=2)

```

- It often makes sense to right- or left-justify the labels relative to the points. To left-justify,
set hjust=0 (Figure 5-32, left), and to right-justify, set hjust=1. As was the case with
vjust, the labels will still slightly overlap with the points. This time, though, it’s not a
good idea to try to fix it by increasing or decreasing hjust. Doing so will shift the labels
a distance proportional to the length of the label, making longer labels move further
than shorter ones. It’s better to just set hjust to 0 or 1, and then add or subtract a bit to
or from x (Figure 5-32, right):

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(countries)

sp <- ggplot(subset(countries, Year==2009 & healthexp>2000),
aes(x=healthexp, y=infmortality)) + geom_point()

sp + geom_text(aes(label=Name), size=4, hjust=0)
sp + geom_text(aes(x=healthexp+100, label=Name), size=4, hjust=0)

```

- If you are using a logarithmic axis, instead of adding to x or y, you’ll need to multiply the x or y value by a number to shift the labels a consistent amount.

- If you want to label just some of the points but want the placement to be handled automatically,
you can add a new column to your data frame containing just the labels you
want. Here’s one way to do that: first we’ll make a copy of the data we’re using, then we’ll
duplicate the Name column into Name1:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(countries)

sp <- ggplot(subset(countries, Year==2009 & healthexp>2000),
aes(x=healthexp, y=infmortality)) + geom_point()

cdat <- subset(countries, Year==2009 & healthexp>2000)
cdat$Name1 <- cdat$Name

```

- Next, we’ll use the %in% operator to find where each name that we want to keep is. This
returns a logical vector indicating which entries in the first vector, cdat$Name1, arepresent in the second vector, in which we specify the names of the countries we want to show:


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(countries)

idx <- cdat$Name1 %in% c("Canada", "Ireland", "United Kingdom", "United States","New Zealand", "Iceland", "Japan", "Luxembourg","Netherlands", "Switzerland")
idx
#Then we’ll use that Boolean vector to overwrite all the other entries in Name1 with NA.

cdat$Name1[!idx] <- NA

#This is what the result looks like

cdat

#Now we can make the plot (Figure 5-33). This time, we’ll also expand the x range so that the text will fit

ggplot(cdat, aes(x=healthexp, y=infmortality)) +geom_point() + geom_text(aes(x=healthexp+100, label=Name1), size=4, hjust=0) + xlim(2000, 10000)

```

- If any individual position adjustments are needed, you have a couple of options. One option is to copy the columns used for the x and y coordinates and modify the numbers for the individual items to move the text around. Make sure to use the original numbers for the coordinates of the points, of course! Another option is to save the output to a vector format such as PDF or SVG, then edit it in a program like Illustrator or Inkscape.

## Creating a Balloon Plot

- You want to make a balloon plot, where the area of the dots is proportional to their numerical value.

- Use geom_point() with scale_size_area(). For this example, we’ll use a subset of the countries data set.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(countries)

cdat <- subset(countries, Year==2009 &
Name %in% c("Canada", "Ireland", "United Kingdom", "United States",
"New Zealand", "Iceland", "Japan", "Luxembourg",
"Netherlands", "Switzerland"))
cdat

```

- If we just map GDP to size, the value of GDP gets mapped to the radius of the dots
(Figure 5-34, left), which is not what we want; a doubling of value results in a quadrupling
of area, and this will distort the interpretation of the data. We instead want to map it to
the area, and we can do this using scale_size_area().

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(countries)

p <- ggplot(cdat, aes(x=healthexp, y=infmortality, size=GDP)) +
geom_point(shape=21, colour="black", fill="cornsilk")

# GDP mapped to radius (default with scale_size_continuous)
p

# GDP mapped to area instead, and larger circles
g<-p + scale_size_area(max_size=15)
g

grid.arrange(p,g,ncol=2)

```

- The example here is a scatter plot, but that is not the only way to use balloon plots. It
may also be useful to use them to represent values on a grid, where the x- and y-axes
are categorical, as in Figure 5-35:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(countries)

# Add up counts for male and female
hec <- HairEyeColor[,,"Male"] + HairEyeColor[,,"Female"]
# Convert to long format
library(reshape2)
hec <- melt(hec, value.name="count")
ggplot(hec, aes(x=Eye, y=Hair)) +
geom_point(aes(size=count), shape=21, colour="black", fill="cornsilk") +
scale_size_area(max_size=20, guide=FALSE) +
geom_text(aes(y=as.numeric(Hair)-sqrt(count)/22, label=count), vjust=1,
colour="grey60", size=4)


```

- In this example we’ve used a few tricks to add the text labels under the circles. First, we
used vjust=1 to top-justify the text to the y coordinate. Next, we wanted to set the y
coordinate so that it is just underneath the bottom of each circle. This requires a little
arithmetic: take the numeric value of Hair and subtract a small value from it, where the
value depends in some way on count. This actually requires taking the square root of
count, since the radius has a linear relationship with the square root of count. The
number that this value divided by (22 in this case) is found by trial and error; it depends
on the particular data values, radius, and text size.

- The text under the circles is in a shade of grey. This is so that it doesn’t jump out at the
viewer and overwhelm the perceptual impact of the circles, but is still available if the
viewer wants to know the exact values.

## Making a Scatter Plot Matrix

- You want to make a scatter plot matrix.

-A scatter plot matrix is an excellent way of visualizing the pairwise relationships among
several variables. To make one, use the pairs() function from R’s base graphics.
For this example, we’ll use a subset of the countries data set. We’ll pull out the data for
the year 2009, and keep only the columns that are relevant:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(countries)

c2009 <- subset(countries, Year==2009,
select=c(Name, GDP, laborrate, healthexp, infmortality))

c2009

pairs(c2009[,2:5])

```

- To make the scatter plot matrix (Figure 5-36), we’ll use columns 2 through 5—using the
Name column wouldn’t make sense, and it would produce strange-looking results:

- We didn’t use ggplot2 here because it doesn’t make scatter plot matrices (at least, not well).

- You can also use customized functions for the panels. To show the correlation coefficient
of each pair of variables instead of a scatter plot, we’ll define the function panel.cor.
This will also show higher correlations in a larger font. Don’t worry about the details
for now—just paste this code into your R session or script:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(countries)

panel.cor <- function(x, y, digits=2, prefix="", cex.cor, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- abs(cor(x, y, use="complete.obs"))
txt <- format(c(r, 0.123456789), digits=digits)[1]
txt <- paste(prefix, txt, sep="")
if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = cex.cor * (1 + r) / 2)
}
#To show histograms of each variable along the diagonal, we’ll define panel.hist:

panel.hist <- function(x, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(usr[1:2], 0, 1.5) )
h <- hist(x, plot = FALSE)
breaks <- h$breaks
nB <- length(breaks)
y <- h$counts
y <- y/max(y)
rect(breaks[-nB], 0, breaks[-1], y, col="white", ...)
}



```

- Both of these panel functions are taken from the pairs help page, so if it’s more convenient,
you can simply open that help page, then copy and paste. The last line of this
version of the panel.cor function is slightly modified, however, so that the changes in
font size aren’t as extreme as with the original.

- Now that we’ve defined these functions we can use them for our scatter plot matrix, by
telling pairs() to use panel.cor for the upper panels and panel.hist for the diagonal
panels.

- We’ll also throw in one more thing: panel.smooth for the lower panels, which makes a
scatter plot and adds a LOWESS smoothed line, as shown in Figure 5-37. (LOWESS is
slightly different from LOESS, which we saw in Recipe 5.6, but the differences aren’t
important for this sort of rough exploratory visualization):



```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(countries)

panel.cor <- function(x, y, digits=2, prefix="", cex.cor, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- abs(cor(x, y, use="complete.obs"))
txt <- format(c(r, 0.123456789), digits=digits)[1]
txt <- paste(prefix, txt, sep="")
if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = cex.cor * (1 + r) / 2)
}

panel.hist <- function(x, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(usr[1:2], 0, 1.5) )
h <- hist(x, plot = FALSE)
breaks <- h$breaks
nB <- length(breaks)
y <- h$counts
y <- y/max(y)
rect(breaks[-nB], 0, breaks[-1], y, col="white", ...)
}

pairs(c2009[,2:5], upper.panel = panel.cor,
diag.panel = panel.hist,
lower.panel = panel.smooth)

```

- It may be more desirable to use linear regression lines instead of LOWESS lines. The
panel.lm function will do the trick (unlike the previous panel functions, this one isn’t
in the pairs help page):

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(gcookbook) # For the data set
library(ggplot2)
library(dplyr)
library(gridExtra)
library(plotly)
library(hexbin)
data(countries)

panel.lm <- function (x, y, col = par("col"), bg = NA, pch = par("pch"),
cex = 1, col.smooth = "black", ...) {
points(x, y, pch = pch, col = col, bg = bg, cex = cex)
abline(stats::lm(y ~ x), col = col.smooth, ...)
}

pairs(c2009[,2:5], pch=".",
upper.panel = panel.cor,
diag.panel = panel.hist,
lower.panel = panel.lm)


```

- This time the default line color is black instead of red, though you can change it here
(and with panel.smooth) by setting col.smooth when you call pairs().
We’ll also use small points in the visualization, so that we can distinguish them a bit
better (Figure 5-38). This is done by setting pch=".":

- The size of the points can also be controlled using the cex parameter. The default value
for cex is 1; make it smaller for smaller points and larger for larger points. Values below .5 might not render properly with PDF output.

- The ggpairs() function from the GGally package can also make scatter plot matrices.







